diff --git a/src/kernel/engine.ts b/src/kernel/engine.ts
index b1f0aa0..412f62b 100644
--- a/src/kernel/engine.ts
+++ b/src/kernel/engine.ts
@@ -26,9 +26,13 @@ export class TuringEngine {
   private l1TraceCache: string[] = [];
   private readonly l1TraceDepth = 3;
   private readonly watchdogDepth = 5;
+  private readonly verificationSignalDepth = 6;
+  private readonly trapLoopDepth = 4;
   private lastObservedPointer?: Pointer;
   private lastObservedSlice?: Slice;
   private lastTrapDetails = new Map<string, string>();
+  private recentVerificationSignals: string[] = [];
+  private trapPointerHistory: string[] = [];
 
   constructor(
     private manifold: IPhysicalManifold,
@@ -131,6 +135,7 @@ export class TuringEngine {
 
     this.lastObservedPointer = pointer;
     this.lastObservedSlice = s_t;
+    this.recordVerificationSignal(pointer, s_t);
 
     // 1.8) Inject managed context channels for short-horizon anti-looping.
     const callStackSlice = await this.observeCallStackSnapshot();
@@ -188,6 +193,25 @@ export class TuringEngine {
 
     // 2.5) HALT guard: block HALT unless acceptance contract is satisfied.
     const haltRequested = q_next.trim() === 'HALT' || d_next.trim() === 'HALT';
+    if (haltRequested) {
+      const verification = this.checkRecentVerificationEvidence();
+      if (!verification.ok) {
+        const trapDetails = [
+          'HALT rejected: physical verification gate is not satisfied.',
+          `Details: ${verification.reason}`,
+          `Recent signals: ${
+            this.recentVerificationSignals.length > 0 ? this.recentVerificationSignals.join(' | ') : '(none)'
+          }`,
+          'Action: run a validation command ($ ls/$ cat/$ npm test/...) and inspect output before HALT.',
+        ].join('\n');
+        this.lastTrapDetails.set('sys://trap/illegal_halt', trapDetails);
+        return [
+          q_t,
+          this.systemTrapPointer('sys://trap/illegal_halt', trapDetails),
+        ];
+      }
+    }
+
     if (haltRequested && this.executionContract) {
       try {
         const haltCheck = await this.executionContract.checkHalt();
@@ -218,6 +242,29 @@ export class TuringEngine {
       }
     }
 
+    const trapLoop = this.trackTrapPointerLoop(d_next);
+    if (trapLoop.loop) {
+      this.watchdogHistory = [];
+      this.l1TraceCache = [];
+      const trapDetails = [
+        'Kernel panic reset: repeated trap pointer loop detected.',
+        `Repeated trap: ${trapLoop.trapBase}`,
+        'Action: abandon current approach and switch to a different diagnosis path immediately.',
+      ].join('\n');
+      this.lastTrapDetails.set('sys://trap/panic_reset', trapDetails);
+      return [
+        [
+          '[OS_PANIC: INFINITE_LOOP_KILLED] Repeated trap loop interrupted.',
+          `Repeated trap: ${trapLoop.trapBase}`,
+          'Action: use a different pointer/command strategy and avoid the last failing function path.',
+          '',
+          '[RECOVERED STATE q]:',
+          q_next,
+        ].join('\n'),
+        this.systemTrapPointer('sys://trap/panic_reset', trapDetails),
+      ];
+    }
+
     // 3) L1 trace pre-watchdog interrupt for short action loops.
     const actionHash = this.actionSignature(d_next, s_prime);
     this.l1TraceCache.push(actionHash);
@@ -290,6 +337,27 @@ export class TuringEngine {
         writePayload = normalized.payload;
       }
 
+      if (!isAppendChannel) {
+        const lazyMarker = this.containsLazyWriteMarker(writePayload);
+        if (lazyMarker) {
+          const trapDetails = [
+            'Content contract violation: write payload contains omission marker.',
+            `Detected marker: ${lazyMarker}`,
+            'Action: output the complete file content with no "... existing ..." placeholders.',
+          ].join('\n');
+          this.lastTrapDetails.set('sys://trap/content_contract', trapDetails);
+          return [
+            [
+              q_next,
+              '',
+              '[OS_TRAP: CONTENT_CONTRACT_VIOLATION] Incomplete payload blocked.',
+              `Details: ${trapDetails}`,
+            ].join('\n'),
+            this.systemTrapPointer('sys://trap/content_contract', trapDetails),
+          ];
+        }
+      }
+
       try {
         await this.manifold.interfere(d_t, writePayload);
       } catch (error: unknown) {
@@ -482,4 +550,104 @@ export class TuringEngine {
       };
     }
   }
+
+  private recordVerificationSignal(pointer: Pointer, observedSlice: Slice): void {
+    if (pointer.startsWith('$')) {
+      const command = pointer.replace(/^\$\s*/, '').trim();
+      if (command.length === 0 || !observedSlice.includes('[EXIT_CODE] 0')) {
+        return;
+      }
+
+      if (this.isVerificationCommand(command)) {
+        this.pushVerificationSignal(`CMD:${command}`);
+      }
+      return;
+    }
+
+    if (pointer.startsWith('sys://') || pointer.trim().length === 0) {
+      return;
+    }
+
+    if (observedSlice.includes('[OS_TRAP: PAGE_FAULT]')) {
+      return;
+    }
+
+    this.pushVerificationSignal(`READ:${pointer}`);
+  }
+
+  private pushVerificationSignal(signal: string): void {
+    const normalized = signal.trim();
+    if (normalized.length === 0) {
+      return;
+    }
+
+    this.recentVerificationSignals.push(normalized.slice(0, 120));
+    if (this.recentVerificationSignals.length > this.verificationSignalDepth) {
+      this.recentVerificationSignals.shift();
+    }
+  }
+
+  private isVerificationCommand(command: string): boolean {
+    const normalized = command.toLowerCase();
+    const patterns = [
+      /\b(ls|cat|head|tail|sed|grep|wc|find|stat|test)\b/,
+      /\b(npm|pnpm|yarn)\s+(test|run\s+\S+)/,
+      /\b(pytest|python|node|tsx|ts-node|go\s+test|cargo\s+test)\b/,
+    ];
+    return patterns.some((pattern) => pattern.test(normalized));
+  }
+
+  private checkRecentVerificationEvidence(): { ok: true } | { ok: false; reason: string } {
+    if (this.recentVerificationSignals.length > 0) {
+      return { ok: true };
+    }
+
+    return {
+      ok: false,
+      reason: 'No recent physical verification evidence was observed.',
+    };
+  }
+
+  private trackTrapPointerLoop(pointer: Pointer): { loop: false } | { loop: true; trapBase: string } {
+    const trimmed = pointer.trim();
+    if (!trimmed.startsWith('sys://trap/')) {
+      this.trapPointerHistory = [];
+      return { loop: false };
+    }
+
+    const trapBase = trimmed.split('?', 1)[0];
+    this.trapPointerHistory.push(trapBase);
+    if (this.trapPointerHistory.length > this.trapLoopDepth) {
+      this.trapPointerHistory.shift();
+    }
+
+    const loopDetected =
+      this.trapPointerHistory.length === this.trapLoopDepth &&
+      this.trapPointerHistory.every((item) => item === trapBase);
+
+    if (loopDetected) {
+      this.trapPointerHistory = [];
+      return { loop: true, trapBase };
+    }
+
+    return { loop: false };
+  }
+
+  private containsLazyWriteMarker(payload: string): string | null {
+    const markers = [
+      /\/\/\s*\.\.\.\s*(existing|rest)/i,
+      /\/\*\s*\.\.\./i,
+      /\b(rest of the code|existing code here)\b/i,
+      /(此处省略|后续省略|略去)/i,
+    ];
+
+    for (const marker of markers) {
+      const matched = payload.match(marker);
+      if (matched?.[0]) {
+        return matched[0];
+      }
+    }
+
+    return null;
+  }
 }
diff --git a/src/oracle/universal-oracle.ts b/src/oracle/universal-oracle.ts
index 3d97d7a..36b8710 100644
--- a/src/oracle/universal-oracle.ts
+++ b/src/oracle/universal-oracle.ts
@@ -17,11 +17,22 @@ interface UniversalOracleConfig {
   model: string;
   baseURL?: string;
   maxOutputTokens?: number;
+  maxRetries?: number;
+  retryBaseDelayMs?: number;
+  retryMaxDelayMs?: number;
+}
+
+interface ErrorWithMetadata extends Error {
+  status?: number;
+  code?: string | number;
 }
 
 export class UniversalOracle implements IOracle {
   private openai?: OpenAI;
   private model: string;
+  private readonly maxRetries: number;
+  private readonly retryBaseDelayMs: number;
+  private readonly retryMaxDelayMs: number;
   private kimimart?: {
     endpoint: string;
     apiKey: string;
@@ -31,6 +42,9 @@ export class UniversalOracle implements IOracle {
 
   constructor(private mode: OracleMode, config: UniversalOracleConfig) {
     this.model = config.model;
+    this.maxRetries = config.maxRetries ?? 6;
+    this.retryBaseDelayMs = config.retryBaseDelayMs ?? 2000;
+    this.retryMaxDelayMs = config.retryMaxDelayMs ?? 60000;
     if (mode === 'openai') {
       const clientConfig: { apiKey: string; baseURL?: string } = { apiKey: config.apiKey };
       if (config.baseURL) {
@@ -70,58 +84,131 @@ export class UniversalOracle implements IOracle {
 
   private async request(prompt: string): Promise<string> {
     if (this.mode === 'openai' && this.openai) {
-      const response = await this.openai.chat.completions.create({
-        model: this.model,
-        messages: [{ role: 'user', content: prompt }],
-        temperature: 0,
-        response_format: { type: 'json_object' },
+      return this.withRetry('openai', async () => {
+        const response = await this.openai!.chat.completions.create({
+          model: this.model,
+          messages: [{ role: 'user', content: prompt }],
+          temperature: 0,
+          response_format: { type: 'json_object' },
+        });
+        return response.choices[0]?.message?.content ?? '{}';
       });
-      return response.choices[0]?.message?.content ?? '{}';
     }
 
     if (this.mode === 'kimi' && this.kimimart) {
-      const response = await fetch(this.kimimart.endpoint, {
-        method: 'POST',
-        headers: {
-          'content-type': 'application/json',
-          'anthropic-version': '2023-06-01',
-          'x-api-key': this.kimimart.apiKey,
-        },
-        body: JSON.stringify({
-          model: this.kimimart.model,
-          max_tokens: this.kimimart.maxOutputTokens,
-          temperature: 0,
-          messages: [{ role: 'user', content: prompt }],
-        }),
+      return this.withRetry('kimi', async () => {
+        const response = await fetch(this.kimimart!.endpoint, {
+          method: 'POST',
+          headers: {
+            'content-type': 'application/json',
+            'anthropic-version': '2023-06-01',
+            'x-api-key': this.kimimart!.apiKey,
+          },
+          body: JSON.stringify({
+            model: this.kimimart!.model,
+            max_tokens: this.kimimart!.maxOutputTokens,
+            temperature: 0,
+            messages: [{ role: 'user', content: prompt }],
+          }),
+        });
+
+        const raw = await response.text();
+        if (!response.ok) {
+          const error = new Error(`Kimi API ${response.status}: ${raw.slice(0, 500)}`) as ErrorWithMetadata;
+          error.status = response.status;
+          throw error;
+        }
+
+        let parsed: KimiMessageResponse;
+        try {
+          parsed = JSON.parse(raw) as KimiMessageResponse;
+        } catch (error: unknown) {
+          const message = error instanceof Error ? error.message : String(error);
+          throw new Error(`Invalid Kimi response JSON: ${message}. Raw: ${raw.slice(0, 500)}`);
+        }
+
+        const text = (parsed.content ?? [])
+          .filter((block) => block.type === 'text' && typeof block.text === 'string')
+          .map((block) => block.text?.trim() ?? '')
+          .filter((line) => line.length > 0)
+          .join('\n');
+
+        if (text.length === 0) {
+          throw new Error(`Empty model output. Raw: ${raw.slice(0, 500)}`);
+        }
+
+        return text;
       });
+    }
 
-      const raw = await response.text();
-      if (!response.ok) {
-        throw new Error(`Kimi API ${response.status}: ${raw.slice(0, 500)}`);
-      }
+    throw new Error('Oracle not configured');
+  }
 
-      let parsed: KimiMessageResponse;
+  private async withRetry(provider: 'openai' | 'kimi', operation: () => Promise<string>): Promise<string> {
+    for (let attempt = 0; attempt <= this.maxRetries; attempt += 1) {
       try {
-        parsed = JSON.parse(raw) as KimiMessageResponse;
+        return await operation();
       } catch (error: unknown) {
-        const message = error instanceof Error ? error.message : String(error);
-        throw new Error(`Invalid Kimi response JSON: ${message}. Raw: ${raw.slice(0, 500)}`);
+        const normalized = this.normalizeError(error);
+        const retryable = this.isRetryable(normalized);
+        const canRetry = attempt < this.maxRetries;
+        if (!retryable || !canRetry) {
+          throw normalized;
+        }
+
+        const delayMs = this.backoffDelay(attempt);
+        const status = normalized.status ?? 'n/a';
+        console.warn(
+          `[oracle:${provider}] transient error; status=${status}; attempt=${attempt + 1}/${
+            this.maxRetries + 1
+          }; retry_in_ms=${delayMs}`
+        );
+        await this.sleep(delayMs);
       }
+    }
 
-      const text = (parsed.content ?? [])
-        .filter((block) => block.type === 'text' && typeof block.text === 'string')
-        .map((block) => block.text?.trim() ?? '')
-        .filter((line) => line.length > 0)
-        .join('\n');
+    throw new Error(`[oracle:${provider}] retry loop exhausted unexpectedly`);
+  }
 
-      if (text.length === 0) {
-        throw new Error(`Empty model output. Raw: ${raw.slice(0, 500)}`);
-      }
+  private normalizeError(error: unknown): ErrorWithMetadata {
+    if (error instanceof Error) {
+      return error as ErrorWithMetadata;
+    }
+
+    return new Error(String(error));
+  }
 
-      return text;
+  private isRetryable(error: ErrorWithMetadata): boolean {
+    const status = typeof error.status === 'number' ? error.status : undefined;
+    if (status && (status === 408 || status === 409 || status === 425 || status === 429 || status >= 500)) {
+      return true;
     }
 
-    throw new Error('Oracle not configured');
+    const code = String(error.code ?? '').toUpperCase();
+    if (['ETIMEDOUT', 'ECONNRESET', 'ECONNREFUSED', 'EAI_AGAIN', 'ENOTFOUND', 'UND_ERR_CONNECT_TIMEOUT'].includes(code)) {
+      return true;
+    }
+
+    const message = error.message.toLowerCase();
+    return (
+      message.includes('timeout') ||
+      message.includes('timed out') ||
+      message.includes('fetch failed') ||
+      message.includes('network') ||
+      message.includes('connection reset') ||
+      message.includes('rate limit') ||
+      message.includes('gateway')
+    );
+  }
+
+  private backoffDelay(attempt: number): number {
+    const exponential = this.retryBaseDelayMs * 2 ** attempt;
+    const jitter = Math.floor(Math.random() * 300);
+    return Math.min(exponential + jitter, this.retryMaxDelayMs);
+  }
+
+  private async sleep(ms: number): Promise<void> {
+    await new Promise((resolve) => setTimeout(resolve, ms));
   }
 
   private parseTransition(rawOutput: string): Transition {
diff --git a/src/runtime/file-execution-contract.ts b/src/runtime/file-execution-contract.ts
index 007e6c6..5e19c9a 100644
--- a/src/runtime/file-execution-contract.ts
+++ b/src/runtime/file-execution-contract.ts
@@ -312,6 +312,78 @@ export class FileExecutionContract implements IExecutionContract {
       };
     }
 
+    const expectation = this.stepExpectations()[stepId];
+    if (!expectation) {
+      return { ok: true };
+    }
+
+    const targetFile = expectation.path;
+    const expectationExists = await this.fileExists(targetFile);
+    if (!expectationExists) {
+      return {
+        ok: false,
+        reason: `required file is missing for DONE:${stepId} -> ${targetFile}.`,
+      };
+    }
+
+    let raw = '';
+    try {
+      raw = await fs.readFile(this.resolveWorkspacePath(targetFile), 'utf-8');
+    } catch (error: unknown) {
+      const message = error instanceof Error ? error.message : String(error);
+      return {
+        ok: false,
+        reason: `required file content mismatch for DONE:${stepId} -> ${targetFile}. read failed: ${message}`,
+      };
+    }
+
+    if (expectation.kind === 'text') {
+      const actual = this.normalizeText(raw);
+      const expected = this.normalizeText(expectation.exact);
+      if (actual !== expected) {
+        const expectedPreview = this.preview(expected);
+        const actualPreview = this.preview(actual);
+        return {
+          ok: false,
+          reason: `required file content mismatch for DONE:${stepId} -> ${targetFile}. expected="${expectedPreview}" actual="${actualPreview}".`,
+        };
+      }
+      return { ok: true };
+    }
+
+    try {
+      const parsed = JSON.parse(raw) as Record<string, unknown>;
+      for (const [key, value] of Object.entries(expectation.expected)) {
+        if (parsed[key] !== value) {
+          const actualValue = parsed[key];
+          return {
+            ok: false,
+            reason: `required file content mismatch for DONE:${stepId} -> ${targetFile}. json key ${key} mismatch. expected=${JSON.stringify(
+              value
+            )} actual=${JSON.stringify(actualValue)}.`,
+          };
+        }
+      }
+    } catch (error: unknown) {
+      const message = error instanceof Error ? error.message : String(error);
+      return {
+        ok: false,
+        reason: `required file content mismatch for DONE:${stepId} -> ${targetFile}. invalid json: ${message}`,
+      };
+    }
+
     return { ok: true };
   }
+
+  private normalizeText(text: string): string {
+    return text.replace(/\r\n/g, '\n').trim();
+  }
+
+  private preview(text: string): string {
+    const compact = text.replace(/\s+/g, ' ').trim();
+    if (compact.length <= 180) {
+      return compact;
+    }
+    return `${compact.slice(0, 177)}...`;
+  }
 }
