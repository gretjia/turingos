# 用图灵机哲学做出一个能通过长周期图灵测试的AI


## 长周期图灵测试与大语言模型的困境


在上一章《图灵测试（Turing Test）》中，我们探讨了图灵测试以及在不同交互带宽下的反图灵测试。现在的生成式大语言模型（LLM）在短时间的纯文本对话中，已经能够极其逼真地模仿人类的语气、情绪甚至逻辑错误，轻而易举地通过以分钟或小时为单位的短周期图灵测试。然而，当我们把时间尺度拉长，当前的LLM就会不可避免地露出机器的底色。


一个真正在社会中生存的人类，其智能不仅仅体现在几分钟的机智对答中。一个真正的人类，在一月之后仍然会记得一个月前发生的重要事件；在一年之后仍然保有基本一致的世界观；在与他人的长期互动中，会逐渐形成稳定的价值取向与个人历史。如果你给一个人类同事布置一个庞杂的“大任务”，他可以在一个月的持续努力中，有条不紊地拆解目标、记录进度、修正路线，最终交付成果。


要求一个智能体具备上述能力，我们称之为“长周期图灵测试”。现有的LLM无法通过这项测试，其根本原因在于上下文长度的物理与算法限制。正如我们在前文所论述的，以 Transformer 为代表的模型在本质上是一种“不可变图灵机”，它们依靠不断增长的上下文窗口来维持全局状态。但上下文窗口不可能无限增长，硬件内存和计算资源的瓶颈注定了LLM的记忆是短暂且缺乏持续性（persistence）的。一旦对话超出了窗口限制，最早的信息就会丢失，LLM便会陷入“失忆”，它所构建的临时人格和世界观也会随之崩塌。


## 重新审视图灵机的洞见：缺少的纸与笔


既然现有的模型无法实现长期的心智延续，我们是否需要一种全新的、颠覆性的神级算法？其实不必。解决这个问题的钥匙，早在几十年前就已经被图灵亲自交到了我们手上。


让我们再次回味《图灵机、图灵完备、神经网络》章里，图灵的那句深刻断言：


> 🗣 **A person provided with paper, pencil, rubber, and subject to strict discipline, is in effect a universal machine.**  
> 一个被提供了纸、铅笔、橡皮，并受到严格纪律约束的人，本质上就是一台通用机器。  
> ——阿兰·图灵 (1912-1954)，(没有获得过图灵奖)


如果把这句话放在今天的大语言模型语境下，我们会发现一个惊人的事实：今天的LLM，其实已经完美扮演了那个“受到严格纪律约束的人”。它内部有着千亿级别的参数，受制于极其严密的数学规则和预训练逻辑，能够极其精准地执行语言理解和符号操作。


但是，现在的LLM是一个被绑在椅子上、两手空空的人。它没有纸，没有铅笔，也没有橡皮。它只能把所有的东西死死记在自己的短期工作记忆（上下文窗口）里，一旦脑子装不下了，前面的事情就只能被迫忘掉。


要跨越这一鸿沟，工程界无需去凭空捏造一套超越现有理论的“神级算法”，而应当回归图灵机哲学的原点。按照图灵机的哲学，要让这个系统完整且具备无限的计算潜力（图灵完备），我们不需要再去改造这个“人”的大脑，我们只需要额外给它提供纸、铅笔和橡皮。只要补齐了这些外部工具，并将它们与LLM紧密结合，我们就能够突破上下文的枷锁，构造出一个能够通过长周期图灵测试的持久化人工智能——更深层次的外部架构讨论参见本的后期章节《群体智慧的架构：⚪⚫⚪反奥利奥理论》。


## 迈向长周期智能：高层工程化实现路径


工程化实现长周期智能的核心，仅仅是将那条被抽离的“纸带”以及与之配套的读写机制，重新交还到它的手中。


以下是将图灵机的标准组件映射到现代人工智能开发逻辑中的高层实现路径。通过严谨地审视这一映射关系，我们不仅能看到该方案的合理性，也能洞察其在哲学与工程层面的微妙差异。


## 文件系统：无限延伸的纸带


图灵机中最具革命性的假设之一，便是那条理论上无限长的纸带（Memory Tape）。在长周期任务中，智能体需要一个不受限于模型上下文窗口的存储空间来维持生命周期的连贯性。


> 📌 本文中我们用 $s$ 代表文件的内容，$d$ 代表文件的路径。


在工程实现中，这对应着文件系统。它不仅存储原始的对话记录，还负责沉淀模型在计算过程中生成的中间推演结果、长期规划、事实清单以及世界观设定。从系统论的角度来看，文件系统克服了单体神经网络在物理内存上的硬性约束。只要存储介质足够庞大，这条“纸带”就可以记录长达数年甚至更久远的信息。它是智能体得以实现“历史持续性”的物理基石。


## 语义化的数据表示：升维的符号集合


图灵机处理的符号集合（Alphabet）通常是极度简化的二进制数字 0 和 1。而在面向人类语言与复杂逻辑的AI系统中，符号被升维成了 token 序列，也就是写在每个文件里的内容。


$$
s=\text{token}_1\ \text{token}_2\ \text{token}_3\ \text{token}_4\ \ldots
$$


通过在文件系统这条“纸带”上不断排列、组合、覆盖这些 token 序列，系统逐步构建出了属于它自己的长期记忆脉络与知识图谱。这种将微观符号组合成宏观意义的过程，正是智能在时间维度上得以演化的外在表现。


## 新老概念对比表


| 经典图灵机 | AI图灵机 |
|---|---|
| 载体 | 纸带 / 文件系统 |
| 操作单位 | 格子（cell）/ 文件 |
| 操作单位的内容 | 只能是 0、1、或空白 / 任何合理长度的 token 序列 |


## 搜索与读写机制：灵活游走的读写头


图灵机依赖一个读写头（Read–Write Head）在纸带上逐格移动，以获取当前所需的输入或覆盖旧有的记录。由于大语言模型无法一次性将无限长的外部数据吞入其有限的上下文窗口，它同样需要一个精确的“头”来定位和读写信息。


在实际系统中，读写头的“读取”功能由搜索与索引机制担任。当系统接收到新的外部刺激时，它会通过搜索算法在庞大的文件系统中定位最相关的历史片段，将其提取并拉回模型的注意力范围。而“写入”与“覆盖”功能，则由模型调用写入相关接口来实现。它可以在文件系统中追加新内容，或者擦除已被证伪的旧观点。


```bash
echo "hello world" >> 1.txt
cat 1.txt
系统的状态 $q$
图灵机内部维护着一个有限状态寄存器（State Register），用于记录机器当前所处的状态 $q$，即控制阶段，从而决定其面对相同符号时应当采取的不同动作。它记录了智能体此刻的宏观意图与微观进度，例如“系统正处于月度目标的总结阶段”或“系统正在进行发散性的头脑风暴”。这种状态的维持至关重要，它确保了系统在面对同一句用户输入时，能够根据自身当前所处的任务节点，给出截然不同且符合逻辑的反馈。
当前上下文状态 $c$
在长周期智能系统中，状态寄存器里的状态（$q$）和读写头检索到的文件（$s$）共同组成大语言模型当前正在处理的“上下文 context”（$c$）。
$$
c=(q,s)
$$
ℹ️ 在实际工程中，系统提示词 $p$ 往往会被一同放进 $q$：


$$
c=(\langle p,q\rangle,s)
$$
模型的推理逻辑：概率化的转移函数 $\delta$
转移函数（Transition Function，$\delta$）是图灵机的核心灵魂。它根据机器的“上下文”（$q,s$），精确指导下一步的操作：切换到什么新状态 $q’$、将当前文件改写成什么新内容 $s’$、以及下一个要读写头访问的新文件的路径 $d’$。
$$
\delta(q,s)=(q’,s’,d’)
$$
在大语言模型构成的系统中，这一“总指挥”的角色由模型自身的推理能力及工程侧预设的执行循环来承担。模型读取上下文 $(q,s)$ 经过内部计算后，输出下一步的行动指令 $(q’,s’,d’)$。
💭 传统图灵机的转移函数是绝对确定性的（Deterministic），而大语言模型的生成逻辑本质上是概率性的（Probabilistic）。不过也同样存在概率性图灵机（Probabilistic Turing Machine）的相关理论。


这种概率性虽然在纯粹的计算中可能引入微小的偏差，但在模拟人类智能的长周期图灵测试中，恰恰是这种非绝对的确定性，赋予了系统一定程度的灵活性与拟真感。
证明AI图灵机是图灵完备的
📐 本文中所描述的AI图灵机是图灵完备的


证明：
在确立了由大语言模型（LLM）与外部文件系统组成的“AI图灵机”架构后，我们需要在理论上严格回答一个核心问题：这个系统真的具备通用计算能力吗？换言之，这个引入了现代AI组件的系统，是否在数学和逻辑意义上达到了“图灵完备”（Turing Complete）？


要证明一个系统是图灵完备的，最直接的标准证明方法是：证明该系统能够模拟任意一台标准的单带确定性图灵机。只要我们的“AI图灵机”能够一丝不苟地复现标准图灵机的每一个动作，它就天然继承了图灵机的所有计算能力。


证明的物理与逻辑准备


基于前文构建的架构，我们进行如下严格的设定与映射，以构建模拟环境：
1. 无限的纸带（文件系统）：我们假设文件系统的存储容量是无限的。我们将无限的纸带离散化为无数个独立的文件，文件路径为 $d_i$（其中 $i$ 为整数，代表纸带上的位置索引）。

2. 符号集合的极简化：虽然 LLM 可以处理复杂的 token 序列，但为了证明的严谨性，我们将输入输出严格限制在最基础的图灵机符号集合中，例如 $s\in{0,1,\text{Blank}}$。每个文件 $d_i$ 内只允许写入这三个基础符号之一。

3. 状态寄存器：系统维持一个文本变量 $q$，表示当前状态。初始状态设为 $q_0$。

4. 转移函数 $\delta$（规则注入）：这是证明的关键。我们将任意一台目标图灵机的“状态转移表”（即它的物理逻辑）作为系统提示词（System Prompt）硬编码输入给大语言模型。提示词的内容是一组穷举的条件分支，例如：

   * “如果当前状态 $q$ 是 $q_1$，且读取的符号 $s$ 是 0，则输出：新状态 $q’$ 为 $q_2$，写入新符号 $s’$ 为 1，下一步访问的文件路径 $d’$ 为 $d_{i+1}$（即向右移动一步）。”



系统的执行循环（Simulation Loop）


当上述准备就绪后，AI图灵机开始进入执行循环。我们观察它的每一步操作是否与标准图灵机完全等价：
      1. 读取（Read）：系统通过外部脚本读取当前文件 $d$ 中的内容，获取当前符号 $s$。

      2. 上下文构建（Context）：系统将当前状态 $q$ 与读取到的符号 $s$ 拼接，形成当前的上下文 $c=(q,s)$，并将其输入给大语言模型。

      3. 状态转移（Transition）：大语言模型根据预先注入的规则（System Prompt），对输入的 $(q,s)$ 进行模式匹配与逻辑推理，严格输出对应的指令元组 $(q’,s’,d’)$。

      4. 写入与移动（Write & Move）：外部系统接收到大语言模型的输出后，将新符号 $s’$ 覆写进当前文件 $d$ 中；将系统的状态寄存器更新为 $q’$；并将读写头的指针移动到新路径 $d’$。

      5. 停机判断（Halt）：如果 $q’$ 为预设的停机状态（Halt State），则系统终止运行；否则，返回第 1 步继续循环。



在这个循环中，大语言模型实际上退化（或者说聚焦）成了一个纯粹的逻辑门电路或查表函数。只要外部的文件系统不崩溃，这个循环就可以无限进行下去。它所执行的每一步 $(q,s)\rightarrow(q’,s’,d’)$，都与数学定义上的标准图灵机分毫不差。


消除概率性带来的干扰


在这个证明中，唯一可能引起质疑的是大语言模型的“概率性”本质。我们在前文中提到过，LLM 本质上是一个基于概率预测下一个 token 的统计模型，它偶尔会产生“幻觉”或不按指令输出。如果转移函数 $\delta$ 存在随机误差，还能称之为确定性的图灵完备吗？


在工程与理论的双重语境下，这个质疑可以通过以下两种方式消除：
         * 工程物理层面：将生成温度（Temperature）设为 $0$。在贪心解码（Greedy Decoding）下，对于完全相同的输入提示词和上下文，模型会坍缩为一个确定性函数，始终输出概率最高的那一条固定结果。

         * 理论哲学层面：图灵完备讨论的是“是否存在一种方式”来实现通用计算。既然可以假设纸带无限长、机械零件永不磨损，同样也可以假设存在一个“被完美纪律化、绝不犯错”的大语言模型。只要它具备执行条件分支（If-Else）的能力，它在理论体系中就是完备的。



小结


综上所述，通过将大语言模型与具备无限存储能力的文件系统结合，并利用外部脚本驱动“读取-推理-写入-移动”的离散循环，我们构建的“AI图灵机”能够严格模拟任意一台单带确定性图灵机的运行过程。


因此，这个系统在数学意义上是图灵完备的。


这一证明虽然枯燥，但其哲学意义极其深远：它向我们确证了，补齐了外部记忆与操作工具的AI系统，其能力天花板不再是“聊天机器人”，而是整个可计算宇宙。只要给予足够的时间与存储空间，这个架构能够计算任何人类理性可以形式化描述的问题，包括且不限于通过长达数年甚至数十年跨度的长周期图灵测试。


$\square$
💭 万物皆文件（Everything is a File）
当我们讨论将文件系统作为图灵机的“纸带”时，我们无意中撞见了计算机科学史上另一个伟大的哲学传统——Unix/Linux 设计哲学。


在 Linux 的世界里，有一个著名的信条：“万物皆文件”。无论是存储在硬盘上的文档、内存里的数据，还是键盘、显示器等硬件设备，甚至是在网络上流动的比特，在操作系统底层都被抽象成了一个个“文件”。


这一哲学与图灵机的构想在此时实现了完美的合流：
            * 标准统一化：如果“万物皆文件”，那么对于那个受纪律约束的人（AI）来说，它就不需要去学习数以千计的底层接口，它只需要掌握一种最简单的技能——读写文件。

            * 无限的扩展性：在图灵机的原始模型中，纸带只是存储符号的介质。但在“万物皆文件”的系统架构下，AI 写入一个文件可能是在记录一段记忆，也可能是在向一个传感器发送指令，甚至是在启动另一个子系统。

            * 路径即位置：在我们的证明中，文件路径 $d$ 充当了读写头的指针。在 Linux 哲学中，路径不仅是硬盘上的一个位置，它可以指向系统的任何角落。



在这个意义上，一个运行在 Linux 哲学之上的 LLM，才真正拥有了图灵所设想的那种“通用的潜力”。它通过读写文件来感知世界、改变世界，并最终在这些文件的往复涂抹中，跨越时间的长度，沉淀出真正的智能。


URL也是文件
在联网的情况下，url 也可以被用作路径 $d$。不过与本地路径不同，url 路径只读不写。
模拟运行
💡 任务目标
在本次模拟游戏中，我们将试图让 AI 回答一个问题：$home1$ 路径里的有很多子路径，还有很多 *.md 文件。每个 *.md 文件里都有一个数字，AI 的任务是求所有这些数字的和是奇数还是偶数。注意，不需要统计数字的和，只需要知道和是奇数还是偶数。


已经创建好了 $home1$ 路径（注意不是 home1）和相应的 *.md 文件。而且每个路径里都有一个隐藏文件 .ls，其内容相当于是运行 ls 命令。
🗒️ 系统提示词 $p$（始终不变）
               * 所有的输入输出皆使用 md 格式（像这样）

               * 你现在扮演的是一个无历史记录的AI图灵机，所以下一回合的你看不到你这一回合的行为，你也不知道当前运行到哪一步了，$q$ 是你唯一的全局观来源。

               * 只有当 $q$ 太长的时候你才应该对 $q$ 做缩减（例如删除一些没有参考价值的历史）

               * $q$ 是用来存指示的，$q$ 不是用来存信息的地方。如果要存信息，你应该自己去建相应的文件。

               * 你自己新创建的每一个文件都应该在 $q$ 里注明路径和用途。

               * [ ] $q$ 里应该包含一个 todo-stack，用 [] 的格式。如果没有，你应该建立一个；如果已经有，你应该不断的更新它。你可以动态调整每个 todo 的位置，越前面越优先，但是不要删除。你需要通过这个 todo-stack 让自己不重复做已经做过的事情，避免让自己陷入死循环。

               * [x] todo-stack 里完成的 todo 不要删掉，而是 check 掉，并移动到 stack 的最后。

               * $s$ 会告诉你当前读写头看的是哪个文件，以及文件的内容。

               * $q’$ 是你给下一回合的你发送的状态 $q’$。为了确保下一回合的你不迷失，$q’$ 尽量应该几乎一字不差保留所有现有回合的状态 $q$ 的内容，然后在此之上做相应的修改。

               * $d’$ 是你下一个要访问的文件的路径。

               * $s’$ 是你要往当前文件 $s$ 里写入的内容（覆盖源文件）。注意 $s’$ 写入的路径是 $s$，不是 $d’$。如果你要往 $d’$ 里写入内容，你应该这回合移动读写头到 $d’$，并在 $q$ 里的 todo 里备注当 $s$ 是某路径时写入某某信息。

               * 如果你不希望修改 $s$，你可以使用特定语句 $s’=\text{👆🏻}$



变量输入
q = …
s = …


输出（你的返回内容必须使用这个模板，不符合这个模板的输出将直接作废重新计算）
q’ = （这个状态将会被作为下一回合你的状态输入）
s’ = （你要往读写头指向的文件里写入的内容；如不修改则 $s’=\text{👆🏻}$）
d’ = （下一个要读写头访问的文件路径）
（下方为模拟日志原文，已保留其中的 LaTeX 与代码；为保持“可被AI完美解析”，建议你后续将日志部分拆分为多段 ```text 块或按回合编号分节。）
结果验证
文件系统如图所示，一共有 4 个原文件。在这个示例中为了方便演示，文件里的数字刚好与文件名一致。所有数字相加的和的确是奇数。AI图灵机的答案正确 ✅。
挑战题：AI图灵机的升级
多线程控制AI图灵机
❓
                  1. 使用搜索引擎和AI等工具，研究如何把一个经典图灵机升级成一个多线程控制的图灵机。

                  2. 使用类似的思路，把一个AI图灵机升级成一个多线程控制的AI图灵机。

历史不可篡改AI图灵机
❓
                     1. 使用搜索引擎和AI等工具，研究如何用 git 工具对文件系统做历史版本控制。

                     2. 每次AI图灵机对文件系统做修改的时候，都做一次 git commit。

终端控制AI图灵机
❓
                        1. AI图灵机的输出 $d$ 不仅可以是文件路径，还可以是终端命令。